"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/holy-loader";
exports.ids = ["vendor-chunks/holy-loader"];
exports.modules = {

/***/ "(ssr)/./node_modules/holy-loader/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/holy-loader/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ src_default),\n/* harmony export */   startHolyLoader: () => (/* binding */ startHolyLoader),\n/* harmony export */   stopHolyLoader: () => (/* binding */ stopHolyLoader)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ default,startHolyLoader,stopHolyLoader auto */ var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __spreadValues = (a, b)=>{\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __name = (target, value)=>__defProp(target, \"name\", {\n        value,\n        configurable: true\n    });\n// src/index.tsx\n\n// src/constants.ts\nvar DEFAULTS = {\n    color: \"#59a2ff\",\n    initialPosition: 0.08,\n    height: 4,\n    easing: \"ease\",\n    speed: 200,\n    zIndex: 2147483647,\n    showSpinner: false,\n    boxShadow: void 0,\n    ignoreSearchParams: false,\n    dir: \"ltr\"\n};\nvar START_HOLY_EVENT = \"holy-progress-start\";\nvar STOP_HOLY_EVENT = \"holy-progress-stop\";\n// src/utils.ts\nvar toAbsoluteURL = /* @__PURE__ */ __name((url)=>{\n    return new URL(url, window.location.href).href;\n}, \"toAbsoluteURL\");\nvar isSamePageAnchor = /* @__PURE__ */ __name((currentUrl, newUrl)=>{\n    const current = new URL(toAbsoluteURL(currentUrl));\n    const next = new URL(toAbsoluteURL(newUrl));\n    return current.href.split(\"#\")[0] === next.href.split(\"#\")[0];\n}, \"isSamePageAnchor\");\nvar isSameHost = /* @__PURE__ */ __name((currentUrl, newUrl)=>{\n    const current = new URL(toAbsoluteURL(currentUrl));\n    const next = new URL(toAbsoluteURL(newUrl));\n    return current.hostname.replace(/^www\\./, \"\") === next.hostname.replace(/^www\\./, \"\");\n}, \"isSameHost\");\nvar paramsAreEqual = /* @__PURE__ */ __name((params1, params2)=>Array.from(params1).every(([key, value])=>params2.has(key) && params2.get(key) === value), \"paramsAreEqual\");\nvar hasSameQueryParameters = /* @__PURE__ */ __name((currentUrl, newUrl)=>{\n    const current = new URL(toAbsoluteURL(currentUrl));\n    const next = newUrl instanceof URL ? newUrl : new URL(toAbsoluteURL(newUrl));\n    const currentParams = new URLSearchParams(current.search);\n    const nextParams = new URLSearchParams(next.search);\n    return paramsAreEqual(currentParams, nextParams) && paramsAreEqual(nextParams, currentParams);\n}, \"hasSameQueryParameters\");\nvar isSamePathname = /* @__PURE__ */ __name((currentUrl, newUrl)=>{\n    const current = new URL(toAbsoluteURL(currentUrl));\n    const next = newUrl instanceof URL ? newUrl : new URL(toAbsoluteURL(newUrl));\n    return current.pathname === next.pathname;\n}, \"isSamePathname\");\nvar clamp = /* @__PURE__ */ __name((n, min, max)=>Math.max(min, Math.min(n, max)), \"clamp\");\nvar queue = /* @__PURE__ */ (()=>{\n    const pending = [];\n    const next = /* @__PURE__ */ __name(()=>{\n        const fn = pending.shift();\n        if (fn !== void 0) {\n            fn(next);\n        }\n    }, \"next\");\n    return (fn)=>{\n        pending.push(fn);\n        if (pending.length === 1) {\n            next();\n        }\n    };\n})();\nvar repaintElement = /* @__PURE__ */ __name((obj)=>{\n    void obj.offsetWidth;\n    return obj;\n}, \"repaintElement\");\n// src/HolyProgress.ts\nvar _HolyProgress = class _HolyProgress {\n    /**\n   * Create a HolyProgress instance.\n   * @param {Partial<HolyProgressProps>} [customSettings] - Optional custom settings to override defaults.\n   */ constructor(customSettings){\n        /**\n     * Sets the progress to a specific value.\n     * @private\n     * @param {number} n - The new progress value (0 to 1).\n     * @returns {HolyProgress} The current instance for chaining methods.\n     */ this.setTo = /* @__PURE__ */ __name((n)=>{\n            const isStarted = typeof this.progressN === \"number\";\n            n = clamp(n, this.settings.initialPosition, 1);\n            this.progressN = n === 1 ? null : n;\n            const progressBar = this.getOrCreateBar(!isStarted);\n            if (!progressBar) {\n                return this;\n            }\n            repaintElement(progressBar);\n            queue((next)=>{\n                if (!this.bar) {\n                    return;\n                }\n                Object.assign(this.bar.style, this.barPositionCSS(n), {\n                    transition: `all ${this.settings.speed}ms ${this.settings.easing}`\n                });\n                if (n === 1) {\n                    progressBar.style.transition = \"none\";\n                    progressBar.style.opacity = \"1\";\n                    repaintElement(progressBar);\n                    setTimeout(()=>{\n                        progressBar.style.transition = `all ${this.settings.speed}ms linear`;\n                        progressBar.style.opacity = \"0\";\n                        setTimeout(()=>{\n                            this.removeBarFromDOM();\n                            next();\n                        }, this.settings.speed);\n                        this.removeSpinnerFromDOM();\n                    }, this.settings.speed);\n                } else {\n                    setTimeout(next, this.settings.speed);\n                }\n            });\n            return this;\n        }, \"setTo\");\n        /**\n     * Converts a progress value (0 to 1) into a percentage representation.\n     * Used for calculating the visual width of the progress bar.\n     * @private\n     * @param {number} n - The progress value to convert.\n     * @returns {number} The percentage representation of the progress value.\n     */ this.toBarPercentage = /* @__PURE__ */ __name((n)=>this.settings.dir === \"ltr\" ? (-1 + n) * 100 : (1 - n) * 100, \"toBarPercentage\");\n        /**\n     * Initiates the progress bar's movement. If already started, it continues from the current position.\n     * Automatically handles automatic incrementation ('trickle') if enabled.\n     * @public\n     * @returns {HolyProgress} The current instance for chaining methods.\n     */ this.start = /* @__PURE__ */ __name(()=>{\n            if (this.progressN === null) {\n                this.setTo(0);\n                this.startTrickle();\n                if (this.settings.showSpinner === true) {\n                    this.createSpinner();\n                }\n            }\n            return this;\n        }, \"start\");\n        /**\n     * Performs automatic incrementation of the progress bar.\n     * This function is recursive and continues to increment the progress at intervals defined by `speed`.\n     * @private\n     */ this.startTrickle = /* @__PURE__ */ __name(()=>{\n            const run = /* @__PURE__ */ __name(()=>{\n                if (this.progressN === null) return;\n                this.incrementStatus();\n                setTimeout(run, this.settings.speed);\n            }, \"run\");\n            setTimeout(run, this.settings.speed);\n        }, \"startTrickle\");\n        /**\n     * Completes the progress, moving it to 100%\n     * @public\n     * @returns {HolyProgress} The current instance for chaining methods.\n     */ this.complete = /* @__PURE__ */ __name(()=>this.setTo(1), \"complete\");\n        /**\n     * Calculates an increment value based on the current status of the progress.\n     * This is used to determine the amount of progress to add during automatic incrementation.\n     * @private\n     * @param {number} status - The current progress status.\n     * @returns {number} The calculated increment value.\n     */ this.calculateIncrement = /* @__PURE__ */ __name((status)=>{\n            const base = 0.1;\n            const scale = 5;\n            return base * Math.exp(-scale * status);\n        }, \"calculateIncrement\");\n        /**\n     * Increments the progress bar by a specified amount, or by an amount determined by `calculateIncrement` if not specified.\n     * @private\n     * @param {number} [amount] - The amount to increment the progress bar.\n     * @returns {HolyProgress} The current instance for chaining methods.\n     */ this.incrementStatus = /* @__PURE__ */ __name((amount)=>{\n            if (this.progressN === null) {\n                return this.start();\n            }\n            if (this.progressN > 1) {\n                return this;\n            }\n            if (typeof amount !== \"number\") {\n                amount = this.calculateIncrement(this.progressN);\n            }\n            this.progressN = clamp(this.progressN + amount, 0, 0.994);\n            return this.setTo(this.progressN);\n        }, \"incrementStatus\");\n        /**\n     * Creates and initializes a new progress bar element in the DOM.\n     * It sets up the necessary styles and appends the element to the document body.\n     * @private\n     * @param {boolean} fromStart - Indicates if the bar is created from the start position.\n     * @returns {HTMLElement | null} The created progress bar element, or null if creation fails.\n     */ this.createBar = /* @__PURE__ */ __name((fromStart)=>{\n            var _a, _b;\n            const barContainer = document.createElement(\"div\");\n            barContainer.id = \"holy-progress\";\n            barContainer.style.pointerEvents = \"none\";\n            barContainer.innerHTML = '<div class=\"bar\" role=\"bar\"></div>';\n            this.bar = barContainer.querySelector('[role=\"bar\"]');\n            if (!this.bar) {\n                return null;\n            }\n            const percentage = this.toBarPercentage(fromStart ? 0 : (_a = this.progressN) != null ? _a : 0);\n            this.bar.style.background = this.settings.color;\n            if (typeof this.settings.height === \"number\") {\n                this.bar.style.height = `${this.settings.height}px`;\n            } else {\n                this.bar.style.height = this.settings.height;\n            }\n            this.bar.style.zIndex = this.settings.zIndex.toString();\n            this.bar.style.position = \"fixed\";\n            this.bar.style.width = \"100%\";\n            this.bar.style.top = \"0\";\n            this.bar.style.left = \"0\";\n            this.bar.style.transition = \"all 0 linear\";\n            this.bar.style.transform = `translate3d(${percentage}%,0,0)`;\n            this.bar.style.boxShadow = (_b = this.settings.boxShadow) != null ? _b : \"\";\n            document.body.appendChild(barContainer);\n            return barContainer;\n        }, \"createBar\");\n        /**\n     * Creates and initializes a new spinner element in the DOM.\n     * It sets up the necessary styles and appends the element to the document body.\n     * @private\n     * @returns {void}\n     */ this.createSpinner = /* @__PURE__ */ __name(()=>{\n            if (document.getElementById(\"holy-progress-spinner\") !== null) {\n                return;\n            }\n            const spinner = document.createElement(\"div\");\n            spinner.id = \"holy-progress-spinner\";\n            spinner.style.pointerEvents = \"none\";\n            spinner.style.display = \"block\";\n            spinner.style.position = \"fixed\";\n            spinner.style.zIndex = this.settings.zIndex.toString();\n            spinner.style.top = \"15px\";\n            spinner.style.right = \"15px\";\n            spinner.style.width = \"18px\";\n            spinner.style.height = \"18px\";\n            spinner.style.boxSizing = \"border-box\";\n            spinner.style.border = \"solid 2px transparent\";\n            spinner.style.borderTopColor = this.settings.color;\n            spinner.style.borderLeftColor = this.settings.color;\n            spinner.style.borderRadius = \"50%\";\n            spinner.style.animation = \"holy-progress-spinner 400ms linear infinite\";\n            const keyframes = `\n      @keyframes holy-progress-spinner {\n        0%   { transform: rotate(0deg); }\n        100% { transform: rotate(360deg); }\n      }\n    `;\n            const style = document.createElement(\"style\");\n            style.innerHTML = keyframes;\n            spinner.appendChild(style);\n            document.body.appendChild(spinner);\n        }, \"createSpinner\");\n        this.getOrCreateBar = /* @__PURE__ */ __name((fromStart)=>{\n            var _a;\n            return (_a = document.getElementById(\"holy-progress\")) != null ? _a : this.createBar(fromStart);\n        }, \"getOrCreateBar\");\n        this.removeBarFromDOM = /* @__PURE__ */ __name(()=>{\n            var _a;\n            return (_a = document.getElementById(\"holy-progress\")) == null ? void 0 : _a.remove();\n        }, \"removeBarFromDOM\");\n        this.removeSpinnerFromDOM = /* @__PURE__ */ __name(()=>{\n            var _a;\n            return (_a = document.getElementById(\"holy-progress-spinner\")) == null ? void 0 : _a.remove();\n        }, \"removeSpinnerFromDOM\");\n        /**\n     * Determines the most suitable CSS positioning strategy based on browser capabilities.\n     * Checks for transform properties with vendor prefixes and standard un-prefixed properties.\n     * @private\n     * @returns {TransformStrategy} - The optimal CSS positioning strategy ('translate3d', 'translate', or 'margin').\n     */ this.getTransformStrategy = /* @__PURE__ */ __name(()=>{\n            const style = document.body.style;\n            const prefixes = [\n                \"Webkit\",\n                \"Moz\",\n                \"ms\",\n                \"O\",\n                \"\"\n            ];\n            let transformProp = \"\";\n            for(let i = 0; i < prefixes.length; i++){\n                if (`${prefixes[i]}Transform` in style) {\n                    transformProp = prefixes[i];\n                    break;\n                }\n            }\n            if (transformProp !== \"\" && `${transformProp}Perspective` in style) {\n                return \"translate3d\";\n            }\n            if (transformProp !== \"\") {\n                return \"translate\";\n            }\n            return \"margin\";\n        }, \"getTransformStrategy\");\n        /**\n     * Generates the CSS for the progress bar position based on the detected positioning strategy.\n     * Dynamically sets the transform or margin-left properties for the bar's position.\n     * @private\n     * @param {number} n - Position value of the bar, as a number between 0 and 1.\n     * @returns {Object} - CSS styles for the progress bar.\n     */ this.barPositionCSS = /* @__PURE__ */ __name((n)=>{\n            const transformStrategy = this.getTransformStrategy();\n            const barPosition = `${this.toBarPercentage(n)}%`;\n            if (transformStrategy === \"translate3d\") {\n                return {\n                    transform: `translate3d(${barPosition},0,0)`\n                };\n            }\n            if (transformStrategy === \"translate\") {\n                return {\n                    transform: `translate(${barPosition},0)`\n                };\n            }\n            return {\n                marginLeft: barPosition\n            };\n        }, \"barPositionCSS\");\n        this.settings = __spreadValues(__spreadValues({}, DEFAULTS), customSettings);\n        this.progressN = null;\n        this.bar = null;\n    }\n};\n__name(_HolyProgress, \"HolyProgress\");\nvar HolyProgress = _HolyProgress;\n// src/index.tsx\nvar startHolyLoader = /* @__PURE__ */ __name(()=>{\n    document.dispatchEvent(new Event(START_HOLY_EVENT));\n}, \"startHolyLoader\");\nvar stopHolyLoader = /* @__PURE__ */ __name(()=>{\n    document.dispatchEvent(new Event(STOP_HOLY_EVENT));\n}, \"stopHolyLoader\");\nvar HolyLoader = /* @__PURE__ */ __name(({ color = DEFAULTS.color, initialPosition = DEFAULTS.initialPosition, height = DEFAULTS.height, easing = DEFAULTS.easing, speed = DEFAULTS.speed, zIndex = DEFAULTS.zIndex, boxShadow = DEFAULTS.boxShadow, showSpinner = DEFAULTS.showSpinner, ignoreSearchParams = DEFAULTS.ignoreSearchParams, dir = DEFAULTS.dir })=>{\n    const holyProgressRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const startProgress = /* @__PURE__ */ __name(()=>{\n            if (holyProgressRef.current === null) {\n                return;\n            }\n            try {\n                holyProgressRef.current.start();\n            } catch (error) {}\n        }, \"startProgress\");\n        const stopProgress = /* @__PURE__ */ __name(()=>{\n            if (holyProgressRef.current === null) {\n                return;\n            }\n            try {\n                holyProgressRef.current.complete();\n            } catch (error) {}\n        }, \"stopProgress\");\n        let isHistoryPatched = false;\n        const stopProgressOnHistoryUpdate = /* @__PURE__ */ __name(()=>{\n            if (isHistoryPatched) {\n                return;\n            }\n            const originalPushState = history.pushState.bind(history);\n            history.pushState = (...args)=>{\n                const url = args[2];\n                if (url && isSamePathname(window.location.href, url) && (ignoreSearchParams || hasSameQueryParameters(window.location.href, url))) {\n                    originalPushState(...args);\n                    return;\n                }\n                stopProgress();\n                originalPushState(...args);\n            };\n            const originalReplaceState = history.replaceState.bind(history);\n            history.replaceState = (...args)=>{\n                const url = args[2];\n                if (url && isSamePathname(window.location.href, url) && (ignoreSearchParams || hasSameQueryParameters(window.location.href, url))) {\n                    originalReplaceState(...args);\n                    return;\n                }\n                stopProgress();\n                originalReplaceState(...args);\n            };\n            isHistoryPatched = true;\n        }, \"stopProgressOnHistoryUpdate\");\n        const handleClick = /* @__PURE__ */ __name((event)=>{\n            try {\n                const target = event.target;\n                const anchor = target.closest(\"a\");\n                const anchorOpensExternally = (anchor == null ? void 0 : anchor.target) && anchor.target !== \"_self\";\n                if (anchor === null || anchorOpensExternally || anchor.hasAttribute(\"download\") || event.ctrlKey || event.metaKey || // Skip if URL points to a different domain\n                !isSameHost(window.location.href, anchor.href) || // Skip if URL is a same-page anchor (href=\"#\", href=\"#top\", etc.).\n                isSamePageAnchor(window.location.href, anchor.href) || // Skip if URL uses a non-http/https protocol (mailto:, tel:, etc.).\n                !toAbsoluteURL(anchor.href).startsWith(\"http\") || // Skip if the URL is the same as the current page\n                isSamePathname(window.location.href, anchor.href) && (ignoreSearchParams || hasSameQueryParameters(window.location.href, anchor.href))) {\n                    return;\n                }\n                startProgress();\n            } catch (error) {\n                stopProgress();\n            }\n        }, \"handleClick\");\n        try {\n            if (holyProgressRef.current === null) {\n                holyProgressRef.current = new HolyProgress({\n                    color,\n                    height,\n                    initialPosition,\n                    easing,\n                    speed,\n                    zIndex,\n                    boxShadow,\n                    showSpinner,\n                    dir\n                });\n            }\n            document.addEventListener(\"click\", handleClick);\n            document.addEventListener(START_HOLY_EVENT, startProgress);\n            document.addEventListener(STOP_HOLY_EVENT, stopProgress);\n            stopProgressOnHistoryUpdate();\n        } catch (error) {}\n        return ()=>{\n            document.removeEventListener(\"click\", handleClick);\n            document.removeEventListener(START_HOLY_EVENT, startProgress);\n            document.removeEventListener(STOP_HOLY_EVENT, stopProgress);\n        };\n    }, [\n        holyProgressRef\n    ]);\n    return null;\n}, \"HolyLoader\");\nvar src_default = HolyLoader;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaG9seS1sb2FkZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OzRGQUNBLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsc0JBQXNCRixPQUFPRyxxQkFBcUI7QUFDdEQsSUFBSUMsZUFBZUosT0FBT0ssU0FBUyxDQUFDQyxjQUFjO0FBQ2xELElBQUlDLGVBQWVQLE9BQU9LLFNBQVMsQ0FBQ0csb0JBQW9CO0FBQ3hELElBQUlDLGtCQUFrQixDQUFDQyxLQUFLQyxLQUFLQyxRQUFVRCxPQUFPRCxNQUFNWCxVQUFVVyxLQUFLQyxLQUFLO1FBQUVFLFlBQVk7UUFBTUMsY0FBYztRQUFNQyxVQUFVO1FBQU1IO0lBQU0sS0FBS0YsR0FBRyxDQUFDQyxJQUFJLEdBQUdDO0FBQzFKLElBQUlJLGlCQUFpQixDQUFDQyxHQUFHQztJQUN2QixJQUFLLElBQUlDLFFBQVFELEtBQU1BLENBQUFBLElBQUksQ0FBQyxHQUMxQixJQUFJZCxhQUFhZ0IsSUFBSSxDQUFDRixHQUFHQyxPQUN2QlYsZ0JBQWdCUSxHQUFHRSxNQUFNRCxDQUFDLENBQUNDLEtBQUs7SUFDcEMsSUFBSWpCLHFCQUNGLEtBQUssSUFBSWlCLFFBQVFqQixvQkFBb0JnQixHQUFJO1FBQ3ZDLElBQUlYLGFBQWFhLElBQUksQ0FBQ0YsR0FBR0MsT0FDdkJWLGdCQUFnQlEsR0FBR0UsTUFBTUQsQ0FBQyxDQUFDQyxLQUFLO0lBQ3BDO0lBQ0YsT0FBT0Y7QUFDVDtBQUNBLElBQUlJLFNBQVMsQ0FBQ0MsUUFBUVYsUUFBVWIsVUFBVXVCLFFBQVEsUUFBUTtRQUFFVjtRQUFPRSxjQUFjO0lBQUs7QUFFdEYsZ0JBQWdCO0FBQ2U7QUFFL0IsbUJBQW1CO0FBQ25CLElBQUlVLFdBQVc7SUFDYkMsT0FBTztJQUNQQyxpQkFBaUI7SUFDakJDLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxPQUFPO0lBQ1BDLFFBQVE7SUFDUkMsYUFBYTtJQUNiQyxXQUFXLEtBQUs7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Olsid2VicGFjazovL25leHQtZWNvbW1lcmNlLXNob3Bjby8uL25vZGVfbW9kdWxlcy9ob2x5LWxvYWRlci9kaXN0L2luZGV4LmpzPzk4ZDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19uYW1lID0gKHRhcmdldCwgdmFsdWUpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwibmFtZVwiLCB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5cbi8vIHNyYy9pbmRleC50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgREVGQVVMVFMgPSB7XG4gIGNvbG9yOiBcIiM1OWEyZmZcIixcbiAgaW5pdGlhbFBvc2l0aW9uOiAwLjA4LFxuICBoZWlnaHQ6IDQsXG4gIGVhc2luZzogXCJlYXNlXCIsXG4gIHNwZWVkOiAyMDAsXG4gIHpJbmRleDogMjE0NzQ4MzY0NyxcbiAgc2hvd1NwaW5uZXI6IGZhbHNlLFxuICBib3hTaGFkb3c6IHZvaWQgMCxcbiAgaWdub3JlU2VhcmNoUGFyYW1zOiBmYWxzZSxcbiAgZGlyOiBcImx0clwiXG59O1xudmFyIFNUQVJUX0hPTFlfRVZFTlQgPSBcImhvbHktcHJvZ3Jlc3Mtc3RhcnRcIjtcbnZhciBTVE9QX0hPTFlfRVZFTlQgPSBcImhvbHktcHJvZ3Jlc3Mtc3RvcFwiO1xuXG4vLyBzcmMvdXRpbHMudHNcbnZhciB0b0Fic29sdXRlVVJMID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgodXJsKSA9PiB7XG4gIHJldHVybiBuZXcgVVJMKHVybCwgd2luZG93LmxvY2F0aW9uLmhyZWYpLmhyZWY7XG59LCBcInRvQWJzb2x1dGVVUkxcIik7XG52YXIgaXNTYW1lUGFnZUFuY2hvciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGN1cnJlbnRVcmwsIG5ld1VybCkgPT4ge1xuICBjb25zdCBjdXJyZW50ID0gbmV3IFVSTCh0b0Fic29sdXRlVVJMKGN1cnJlbnRVcmwpKTtcbiAgY29uc3QgbmV4dCA9IG5ldyBVUkwodG9BYnNvbHV0ZVVSTChuZXdVcmwpKTtcbiAgcmV0dXJuIGN1cnJlbnQuaHJlZi5zcGxpdChcIiNcIilbMF0gPT09IG5leHQuaHJlZi5zcGxpdChcIiNcIilbMF07XG59LCBcImlzU2FtZVBhZ2VBbmNob3JcIik7XG52YXIgaXNTYW1lSG9zdCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGN1cnJlbnRVcmwsIG5ld1VybCkgPT4ge1xuICBjb25zdCBjdXJyZW50ID0gbmV3IFVSTCh0b0Fic29sdXRlVVJMKGN1cnJlbnRVcmwpKTtcbiAgY29uc3QgbmV4dCA9IG5ldyBVUkwodG9BYnNvbHV0ZVVSTChuZXdVcmwpKTtcbiAgcmV0dXJuIGN1cnJlbnQuaG9zdG5hbWUucmVwbGFjZSgvXnd3d1xcLi8sIFwiXCIpID09PSBuZXh0Lmhvc3RuYW1lLnJlcGxhY2UoL153d3dcXC4vLCBcIlwiKTtcbn0sIFwiaXNTYW1lSG9zdFwiKTtcbnZhciBwYXJhbXNBcmVFcXVhbCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHBhcmFtczEsIHBhcmFtczIpID0+IEFycmF5LmZyb20ocGFyYW1zMSkuZXZlcnkoXG4gIChba2V5LCB2YWx1ZV0pID0+IHBhcmFtczIuaGFzKGtleSkgJiYgcGFyYW1zMi5nZXQoa2V5KSA9PT0gdmFsdWVcbiksIFwicGFyYW1zQXJlRXF1YWxcIik7XG52YXIgaGFzU2FtZVF1ZXJ5UGFyYW1ldGVycyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGN1cnJlbnRVcmwsIG5ld1VybCkgPT4ge1xuICBjb25zdCBjdXJyZW50ID0gbmV3IFVSTCh0b0Fic29sdXRlVVJMKGN1cnJlbnRVcmwpKTtcbiAgY29uc3QgbmV4dCA9IG5ld1VybCBpbnN0YW5jZW9mIFVSTCA/IG5ld1VybCA6IG5ldyBVUkwodG9BYnNvbHV0ZVVSTChuZXdVcmwpKTtcbiAgY29uc3QgY3VycmVudFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoY3VycmVudC5zZWFyY2gpO1xuICBjb25zdCBuZXh0UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhuZXh0LnNlYXJjaCk7XG4gIHJldHVybiBwYXJhbXNBcmVFcXVhbChjdXJyZW50UGFyYW1zLCBuZXh0UGFyYW1zKSAmJiBwYXJhbXNBcmVFcXVhbChuZXh0UGFyYW1zLCBjdXJyZW50UGFyYW1zKTtcbn0sIFwiaGFzU2FtZVF1ZXJ5UGFyYW1ldGVyc1wiKTtcbnZhciBpc1NhbWVQYXRobmFtZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGN1cnJlbnRVcmwsIG5ld1VybCkgPT4ge1xuICBjb25zdCBjdXJyZW50ID0gbmV3IFVSTCh0b0Fic29sdXRlVVJMKGN1cnJlbnRVcmwpKTtcbiAgY29uc3QgbmV4dCA9IG5ld1VybCBpbnN0YW5jZW9mIFVSTCA/IG5ld1VybCA6IG5ldyBVUkwodG9BYnNvbHV0ZVVSTChuZXdVcmwpKTtcbiAgcmV0dXJuIGN1cnJlbnQucGF0aG5hbWUgPT09IG5leHQucGF0aG5hbWU7XG59LCBcImlzU2FtZVBhdGhuYW1lXCIpO1xudmFyIGNsYW1wID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgobiwgbWluLCBtYXgpID0+IE1hdGgubWF4KG1pbiwgTWF0aC5taW4obiwgbWF4KSksIFwiY2xhbXBcIik7XG52YXIgcXVldWUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgY29uc3QgcGVuZGluZyA9IFtdO1xuICBjb25zdCBuZXh0ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiB7XG4gICAgY29uc3QgZm4gPSBwZW5kaW5nLnNoaWZ0KCk7XG4gICAgaWYgKGZuICE9PSB2b2lkIDApIHtcbiAgICAgIGZuKG5leHQpO1xuICAgIH1cbiAgfSwgXCJuZXh0XCIpO1xuICByZXR1cm4gKGZuKSA9PiB7XG4gICAgcGVuZGluZy5wdXNoKGZuKTtcbiAgICBpZiAocGVuZGluZy5sZW5ndGggPT09IDEpIHtcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gIH07XG59KSgpO1xudmFyIHJlcGFpbnRFbGVtZW50ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgob2JqKSA9PiB7XG4gIHZvaWQgb2JqLm9mZnNldFdpZHRoO1xuICByZXR1cm4gb2JqO1xufSwgXCJyZXBhaW50RWxlbWVudFwiKTtcblxuLy8gc3JjL0hvbHlQcm9ncmVzcy50c1xudmFyIF9Ib2x5UHJvZ3Jlc3MgPSBjbGFzcyBfSG9seVByb2dyZXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIEhvbHlQcm9ncmVzcyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtQYXJ0aWFsPEhvbHlQcm9ncmVzc1Byb3BzPn0gW2N1c3RvbVNldHRpbmdzXSAtIE9wdGlvbmFsIGN1c3RvbSBzZXR0aW5ncyB0byBvdmVycmlkZSBkZWZhdWx0cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGN1c3RvbVNldHRpbmdzKSB7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcHJvZ3Jlc3MgdG8gYSBzcGVjaWZpYyB2YWx1ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gVGhlIG5ldyBwcm9ncmVzcyB2YWx1ZSAoMCB0byAxKS5cbiAgICAgKiBAcmV0dXJucyB7SG9seVByb2dyZXNzfSBUaGUgY3VycmVudCBpbnN0YW5jZSBmb3IgY2hhaW5pbmcgbWV0aG9kcy5cbiAgICAgKi9cbiAgICB0aGlzLnNldFRvID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgobikgPT4ge1xuICAgICAgY29uc3QgaXNTdGFydGVkID0gdHlwZW9mIHRoaXMucHJvZ3Jlc3NOID09PSBcIm51bWJlclwiO1xuICAgICAgbiA9IGNsYW1wKG4sIHRoaXMuc2V0dGluZ3MuaW5pdGlhbFBvc2l0aW9uLCAxKTtcbiAgICAgIHRoaXMucHJvZ3Jlc3NOID0gbiA9PT0gMSA/IG51bGwgOiBuO1xuICAgICAgY29uc3QgcHJvZ3Jlc3NCYXIgPSB0aGlzLmdldE9yQ3JlYXRlQmFyKCFpc1N0YXJ0ZWQpO1xuICAgICAgaWYgKCFwcm9ncmVzc0Jhcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJlcGFpbnRFbGVtZW50KHByb2dyZXNzQmFyKTtcbiAgICAgIHF1ZXVlKChuZXh0KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5iYXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmJhci5zdHlsZSwgdGhpcy5iYXJQb3NpdGlvbkNTUyhuKSwge1xuICAgICAgICAgIHRyYW5zaXRpb246IGBhbGwgJHt0aGlzLnNldHRpbmdzLnNwZWVkfW1zICR7dGhpcy5zZXR0aW5ncy5lYXNpbmd9YFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgICBwcm9ncmVzc0Jhci5zdHlsZS50cmFuc2l0aW9uID0gXCJub25lXCI7XG4gICAgICAgICAgcHJvZ3Jlc3NCYXIuc3R5bGUub3BhY2l0eSA9IFwiMVwiO1xuICAgICAgICAgIHJlcGFpbnRFbGVtZW50KHByb2dyZXNzQmFyKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHByb2dyZXNzQmFyLnN0eWxlLnRyYW5zaXRpb24gPSBgYWxsICR7dGhpcy5zZXR0aW5ncy5zcGVlZH1tcyBsaW5lYXJgO1xuICAgICAgICAgICAgcHJvZ3Jlc3NCYXIuc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlQmFyRnJvbURPTSgpO1xuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9LCB0aGlzLnNldHRpbmdzLnNwZWVkKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU3Bpbm5lckZyb21ET00oKTtcbiAgICAgICAgICB9LCB0aGlzLnNldHRpbmdzLnNwZWVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KG5leHQsIHRoaXMuc2V0dGluZ3Muc3BlZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIFwic2V0VG9cIik7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBwcm9ncmVzcyB2YWx1ZSAoMCB0byAxKSBpbnRvIGEgcGVyY2VudGFnZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBVc2VkIGZvciBjYWxjdWxhdGluZyB0aGUgdmlzdWFsIHdpZHRoIG9mIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBwcm9ncmVzcyB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBwZXJjZW50YWdlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcm9ncmVzcyB2YWx1ZS5cbiAgICAgKi9cbiAgICB0aGlzLnRvQmFyUGVyY2VudGFnZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG4pID0+IHRoaXMuc2V0dGluZ3MuZGlyID09PSBcImx0clwiID8gKC0xICsgbikgKiAxMDAgOiAoMSAtIG4pICogMTAwLCBcInRvQmFyUGVyY2VudGFnZVwiKTtcbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZXMgdGhlIHByb2dyZXNzIGJhcidzIG1vdmVtZW50LiBJZiBhbHJlYWR5IHN0YXJ0ZWQsIGl0IGNvbnRpbnVlcyBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAqIEF1dG9tYXRpY2FsbHkgaGFuZGxlcyBhdXRvbWF0aWMgaW5jcmVtZW50YXRpb24gKCd0cmlja2xlJykgaWYgZW5hYmxlZC5cbiAgICAgKiBAcHVibGljXG4gICAgICogQHJldHVybnMge0hvbHlQcm9ncmVzc30gVGhlIGN1cnJlbnQgaW5zdGFuY2UgZm9yIGNoYWluaW5nIG1ldGhvZHMuXG4gICAgICovXG4gICAgdGhpcy5zdGFydCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucHJvZ3Jlc3NOID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2V0VG8oMCk7XG4gICAgICAgIHRoaXMuc3RhcnRUcmlja2xlKCk7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNob3dTcGlubmVyID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5jcmVhdGVTcGlubmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIFwic3RhcnRcIik7XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYXV0b21hdGljIGluY3JlbWVudGF0aW9uIG9mIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyByZWN1cnNpdmUgYW5kIGNvbnRpbnVlcyB0byBpbmNyZW1lbnQgdGhlIHByb2dyZXNzIGF0IGludGVydmFscyBkZWZpbmVkIGJ5IGBzcGVlZGAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0VHJpY2tsZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4ge1xuICAgICAgY29uc3QgcnVuID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb2dyZXNzTiA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICB0aGlzLmluY3JlbWVudFN0YXR1cygpO1xuICAgICAgICBzZXRUaW1lb3V0KHJ1biwgdGhpcy5zZXR0aW5ncy5zcGVlZCk7XG4gICAgICB9LCBcInJ1blwiKTtcbiAgICAgIHNldFRpbWVvdXQocnVuLCB0aGlzLnNldHRpbmdzLnNwZWVkKTtcbiAgICB9LCBcInN0YXJ0VHJpY2tsZVwiKTtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZXMgdGhlIHByb2dyZXNzLCBtb3ZpbmcgaXQgdG8gMTAwJVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcmV0dXJucyB7SG9seVByb2dyZXNzfSBUaGUgY3VycmVudCBpbnN0YW5jZSBmb3IgY2hhaW5pbmcgbWV0aG9kcy5cbiAgICAgKi9cbiAgICB0aGlzLmNvbXBsZXRlID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiB0aGlzLnNldFRvKDEpLCBcImNvbXBsZXRlXCIpO1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgYW4gaW5jcmVtZW50IHZhbHVlIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgcHJvZ3Jlc3MuXG4gICAgICogVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgYW1vdW50IG9mIHByb2dyZXNzIHRvIGFkZCBkdXJpbmcgYXV0b21hdGljIGluY3JlbWVudGF0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXR1cyAtIFRoZSBjdXJyZW50IHByb2dyZXNzIHN0YXR1cy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY2FsY3VsYXRlZCBpbmNyZW1lbnQgdmFsdWUuXG4gICAgICovXG4gICAgdGhpcy5jYWxjdWxhdGVJbmNyZW1lbnQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzdGF0dXMpID0+IHtcbiAgICAgIGNvbnN0IGJhc2UgPSAwLjE7XG4gICAgICBjb25zdCBzY2FsZSA9IDU7XG4gICAgICByZXR1cm4gYmFzZSAqIE1hdGguZXhwKC1zY2FsZSAqIHN0YXR1cyk7XG4gICAgfSwgXCJjYWxjdWxhdGVJbmNyZW1lbnRcIik7XG4gICAgLyoqXG4gICAgICogSW5jcmVtZW50cyB0aGUgcHJvZ3Jlc3MgYmFyIGJ5IGEgc3BlY2lmaWVkIGFtb3VudCwgb3IgYnkgYW4gYW1vdW50IGRldGVybWluZWQgYnkgYGNhbGN1bGF0ZUluY3JlbWVudGAgaWYgbm90IHNwZWNpZmllZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYW1vdW50XSAtIFRoZSBhbW91bnQgdG8gaW5jcmVtZW50IHRoZSBwcm9ncmVzcyBiYXIuXG4gICAgICogQHJldHVybnMge0hvbHlQcm9ncmVzc30gVGhlIGN1cnJlbnQgaW5zdGFuY2UgZm9yIGNoYWluaW5nIG1ldGhvZHMuXG4gICAgICovXG4gICAgdGhpcy5pbmNyZW1lbnRTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChhbW91bnQpID0+IHtcbiAgICAgIGlmICh0aGlzLnByb2dyZXNzTiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJvZ3Jlc3NOID4gMSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYW1vdW50ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGFtb3VudCA9IHRoaXMuY2FsY3VsYXRlSW5jcmVtZW50KHRoaXMucHJvZ3Jlc3NOKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJvZ3Jlc3NOID0gY2xhbXAodGhpcy5wcm9ncmVzc04gKyBhbW91bnQsIDAsIDAuOTk0KTtcbiAgICAgIHJldHVybiB0aGlzLnNldFRvKHRoaXMucHJvZ3Jlc3NOKTtcbiAgICB9LCBcImluY3JlbWVudFN0YXR1c1wiKTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyBhIG5ldyBwcm9ncmVzcyBiYXIgZWxlbWVudCBpbiB0aGUgRE9NLlxuICAgICAqIEl0IHNldHMgdXAgdGhlIG5lY2Vzc2FyeSBzdHlsZXMgYW5kIGFwcGVuZHMgdGhlIGVsZW1lbnQgdG8gdGhlIGRvY3VtZW50IGJvZHkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZyb21TdGFydCAtIEluZGljYXRlcyBpZiB0aGUgYmFyIGlzIGNyZWF0ZWQgZnJvbSB0aGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH0gVGhlIGNyZWF0ZWQgcHJvZ3Jlc3MgYmFyIGVsZW1lbnQsIG9yIG51bGwgaWYgY3JlYXRpb24gZmFpbHMuXG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVCYXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChmcm9tU3RhcnQpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBiYXJDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgYmFyQ29udGFpbmVyLmlkID0gXCJob2x5LXByb2dyZXNzXCI7XG4gICAgICBiYXJDb250YWluZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgYmFyQ29udGFpbmVyLmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwiYmFyXCIgcm9sZT1cImJhclwiPjwvZGl2Pic7XG4gICAgICB0aGlzLmJhciA9IGJhckNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAnW3JvbGU9XCJiYXJcIl0nXG4gICAgICApO1xuICAgICAgaWYgKCF0aGlzLmJhcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSB0aGlzLnRvQmFyUGVyY2VudGFnZShcbiAgICAgICAgZnJvbVN0YXJ0ID8gMCA6IChfYSA9IHRoaXMucHJvZ3Jlc3NOKSAhPSBudWxsID8gX2EgOiAwXG4gICAgICApO1xuICAgICAgdGhpcy5iYXIuc3R5bGUuYmFja2dyb3VuZCA9IHRoaXMuc2V0dGluZ3MuY29sb3I7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuc2V0dGluZ3MuaGVpZ2h0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMuYmFyLnN0eWxlLmhlaWdodCA9IGAke3RoaXMuc2V0dGluZ3MuaGVpZ2h0fXB4YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmFyLnN0eWxlLmhlaWdodCA9IHRoaXMuc2V0dGluZ3MuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgdGhpcy5iYXIuc3R5bGUuekluZGV4ID0gdGhpcy5zZXR0aW5ncy56SW5kZXgudG9TdHJpbmcoKTtcbiAgICAgIHRoaXMuYmFyLnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgICAgdGhpcy5iYXIuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgIHRoaXMuYmFyLnN0eWxlLnRvcCA9IFwiMFwiO1xuICAgICAgdGhpcy5iYXIuc3R5bGUubGVmdCA9IFwiMFwiO1xuICAgICAgdGhpcy5iYXIuc3R5bGUudHJhbnNpdGlvbiA9IFwiYWxsIDAgbGluZWFyXCI7XG4gICAgICB0aGlzLmJhci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHtwZXJjZW50YWdlfSUsMCwwKWA7XG4gICAgICB0aGlzLmJhci5zdHlsZS5ib3hTaGFkb3cgPSAoX2IgPSB0aGlzLnNldHRpbmdzLmJveFNoYWRvdykgIT0gbnVsbCA/IF9iIDogXCJcIjtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYmFyQ29udGFpbmVyKTtcbiAgICAgIHJldHVybiBiYXJDb250YWluZXI7XG4gICAgfSwgXCJjcmVhdGVCYXJcIik7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgYSBuZXcgc3Bpbm5lciBlbGVtZW50IGluIHRoZSBET00uXG4gICAgICogSXQgc2V0cyB1cCB0aGUgbmVjZXNzYXJ5IHN0eWxlcyBhbmQgYXBwZW5kcyB0aGUgZWxlbWVudCB0byB0aGUgZG9jdW1lbnQgYm9keS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHRoaXMuY3JlYXRlU3Bpbm5lciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4ge1xuICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaG9seS1wcm9ncmVzcy1zcGlubmVyXCIpICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgc3Bpbm5lci5pZCA9IFwiaG9seS1wcm9ncmVzcy1zcGlubmVyXCI7XG4gICAgICBzcGlubmVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICAgIHNwaW5uZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIHNwaW5uZXIuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgICBzcGlubmVyLnN0eWxlLnpJbmRleCA9IHRoaXMuc2V0dGluZ3MuekluZGV4LnRvU3RyaW5nKCk7XG4gICAgICBzcGlubmVyLnN0eWxlLnRvcCA9IFwiMTVweFwiO1xuICAgICAgc3Bpbm5lci5zdHlsZS5yaWdodCA9IFwiMTVweFwiO1xuICAgICAgc3Bpbm5lci5zdHlsZS53aWR0aCA9IFwiMThweFwiO1xuICAgICAgc3Bpbm5lci5zdHlsZS5oZWlnaHQgPSBcIjE4cHhcIjtcbiAgICAgIHNwaW5uZXIuc3R5bGUuYm94U2l6aW5nID0gXCJib3JkZXItYm94XCI7XG4gICAgICBzcGlubmVyLnN0eWxlLmJvcmRlciA9IFwic29saWQgMnB4IHRyYW5zcGFyZW50XCI7XG4gICAgICBzcGlubmVyLnN0eWxlLmJvcmRlclRvcENvbG9yID0gdGhpcy5zZXR0aW5ncy5jb2xvcjtcbiAgICAgIHNwaW5uZXIuc3R5bGUuYm9yZGVyTGVmdENvbG9yID0gdGhpcy5zZXR0aW5ncy5jb2xvcjtcbiAgICAgIHNwaW5uZXIuc3R5bGUuYm9yZGVyUmFkaXVzID0gXCI1MCVcIjtcbiAgICAgIHNwaW5uZXIuc3R5bGUuYW5pbWF0aW9uID0gXCJob2x5LXByb2dyZXNzLXNwaW5uZXIgNDAwbXMgbGluZWFyIGluZmluaXRlXCI7XG4gICAgICBjb25zdCBrZXlmcmFtZXMgPSBgXG4gICAgICBAa2V5ZnJhbWVzIGhvbHktcHJvZ3Jlc3Mtc3Bpbm5lciB7XG4gICAgICAgIDAlICAgeyB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxuICAgICAgICAxMDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfVxuICAgICAgfVxuICAgIGA7XG4gICAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIHN0eWxlLmlubmVySFRNTCA9IGtleWZyYW1lcztcbiAgICAgIHNwaW5uZXIuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzcGlubmVyKTtcbiAgICB9LCBcImNyZWF0ZVNwaW5uZXJcIik7XG4gICAgdGhpcy5nZXRPckNyZWF0ZUJhciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGZyb21TdGFydCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaG9seS1wcm9ncmVzc1wiKSkgIT0gbnVsbCA/IF9hIDogdGhpcy5jcmVhdGVCYXIoZnJvbVN0YXJ0KTtcbiAgICB9LCBcImdldE9yQ3JlYXRlQmFyXCIpO1xuICAgIHRoaXMucmVtb3ZlQmFyRnJvbURPTSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaG9seS1wcm9ncmVzc1wiKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgIH0sIFwicmVtb3ZlQmFyRnJvbURPTVwiKTtcbiAgICB0aGlzLnJlbW92ZVNwaW5uZXJGcm9tRE9NID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJob2x5LXByb2dyZXNzLXNwaW5uZXJcIikpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZW1vdmUoKTtcbiAgICB9LCBcInJlbW92ZVNwaW5uZXJGcm9tRE9NXCIpO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIG1vc3Qgc3VpdGFibGUgQ1NTIHBvc2l0aW9uaW5nIHN0cmF0ZWd5IGJhc2VkIG9uIGJyb3dzZXIgY2FwYWJpbGl0aWVzLlxuICAgICAqIENoZWNrcyBmb3IgdHJhbnNmb3JtIHByb3BlcnRpZXMgd2l0aCB2ZW5kb3IgcHJlZml4ZXMgYW5kIHN0YW5kYXJkIHVuLXByZWZpeGVkIHByb3BlcnRpZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNmb3JtU3RyYXRlZ3l9IC0gVGhlIG9wdGltYWwgQ1NTIHBvc2l0aW9uaW5nIHN0cmF0ZWd5ICgndHJhbnNsYXRlM2QnLCAndHJhbnNsYXRlJywgb3IgJ21hcmdpbicpLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0VHJhbnNmb3JtU3RyYXRlZ3kgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IHtcbiAgICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgIGNvbnN0IHByZWZpeGVzID0gW1wiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiwgXCJPXCIsIFwiXCJdO1xuICAgICAgbGV0IHRyYW5zZm9ybVByb3AgPSBcIlwiO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYCR7cHJlZml4ZXNbaV19VHJhbnNmb3JtYCBpbiBzdHlsZSkge1xuICAgICAgICAgIHRyYW5zZm9ybVByb3AgPSBwcmVmaXhlc1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybVByb3AgIT09IFwiXCIgJiYgYCR7dHJhbnNmb3JtUHJvcH1QZXJzcGVjdGl2ZWAgaW4gc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlM2RcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm1Qcm9wICE9PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwibWFyZ2luXCI7XG4gICAgfSwgXCJnZXRUcmFuc2Zvcm1TdHJhdGVneVwiKTtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIENTUyBmb3IgdGhlIHByb2dyZXNzIGJhciBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgZGV0ZWN0ZWQgcG9zaXRpb25pbmcgc3RyYXRlZ3kuXG4gICAgICogRHluYW1pY2FsbHkgc2V0cyB0aGUgdHJhbnNmb3JtIG9yIG1hcmdpbi1sZWZ0IHByb3BlcnRpZXMgZm9yIHRoZSBiYXIncyBwb3NpdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gUG9zaXRpb24gdmFsdWUgb2YgdGhlIGJhciwgYXMgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IC0gQ1NTIHN0eWxlcyBmb3IgdGhlIHByb2dyZXNzIGJhci5cbiAgICAgKi9cbiAgICB0aGlzLmJhclBvc2l0aW9uQ1NTID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgobikgPT4ge1xuICAgICAgY29uc3QgdHJhbnNmb3JtU3RyYXRlZ3kgPSB0aGlzLmdldFRyYW5zZm9ybVN0cmF0ZWd5KCk7XG4gICAgICBjb25zdCBiYXJQb3NpdGlvbiA9IGAke3RoaXMudG9CYXJQZXJjZW50YWdlKG4pfSVgO1xuICAgICAgaWYgKHRyYW5zZm9ybVN0cmF0ZWd5ID09PSBcInRyYW5zbGF0ZTNkXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHtiYXJQb3NpdGlvbn0sMCwwKWAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm1TdHJhdGVneSA9PT0gXCJ0cmFuc2xhdGVcIikge1xuICAgICAgICByZXR1cm4geyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtiYXJQb3NpdGlvbn0sMClgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBtYXJnaW5MZWZ0OiBiYXJQb3NpdGlvbiB9O1xuICAgIH0sIFwiYmFyUG9zaXRpb25DU1NcIik7XG4gICAgdGhpcy5zZXR0aW5ncyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBERUZBVUxUUyksIGN1c3RvbVNldHRpbmdzKTtcbiAgICB0aGlzLnByb2dyZXNzTiA9IG51bGw7XG4gICAgdGhpcy5iYXIgPSBudWxsO1xuICB9XG59O1xuX19uYW1lKF9Ib2x5UHJvZ3Jlc3MsIFwiSG9seVByb2dyZXNzXCIpO1xudmFyIEhvbHlQcm9ncmVzcyA9IF9Ib2x5UHJvZ3Jlc3M7XG5cbi8vIHNyYy9pbmRleC50c3hcbnZhciBzdGFydEhvbHlMb2FkZXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IHtcbiAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoU1RBUlRfSE9MWV9FVkVOVCkpO1xufSwgXCJzdGFydEhvbHlMb2FkZXJcIik7XG52YXIgc3RvcEhvbHlMb2FkZXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IHtcbiAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoU1RPUF9IT0xZX0VWRU5UKSk7XG59LCBcInN0b3BIb2x5TG9hZGVyXCIpO1xudmFyIEhvbHlMb2FkZXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCh7XG4gIGNvbG9yID0gREVGQVVMVFMuY29sb3IsXG4gIGluaXRpYWxQb3NpdGlvbiA9IERFRkFVTFRTLmluaXRpYWxQb3NpdGlvbixcbiAgaGVpZ2h0ID0gREVGQVVMVFMuaGVpZ2h0LFxuICBlYXNpbmcgPSBERUZBVUxUUy5lYXNpbmcsXG4gIHNwZWVkID0gREVGQVVMVFMuc3BlZWQsXG4gIHpJbmRleCA9IERFRkFVTFRTLnpJbmRleCxcbiAgYm94U2hhZG93ID0gREVGQVVMVFMuYm94U2hhZG93LFxuICBzaG93U3Bpbm5lciA9IERFRkFVTFRTLnNob3dTcGlubmVyLFxuICBpZ25vcmVTZWFyY2hQYXJhbXMgPSBERUZBVUxUUy5pZ25vcmVTZWFyY2hQYXJhbXMsXG4gIGRpciA9IERFRkFVTFRTLmRpclxufSkgPT4ge1xuICBjb25zdCBob2x5UHJvZ3Jlc3NSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc3RhcnRQcm9ncmVzcyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4ge1xuICAgICAgaWYgKGhvbHlQcm9ncmVzc1JlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGhvbHlQcm9ncmVzc1JlZi5jdXJyZW50LnN0YXJ0KCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgfVxuICAgIH0sIFwic3RhcnRQcm9ncmVzc1wiKTtcbiAgICBjb25zdCBzdG9wUHJvZ3Jlc3MgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IHtcbiAgICAgIGlmIChob2x5UHJvZ3Jlc3NSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBob2x5UHJvZ3Jlc3NSZWYuY3VycmVudC5jb21wbGV0ZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIH1cbiAgICB9LCBcInN0b3BQcm9ncmVzc1wiKTtcbiAgICBsZXQgaXNIaXN0b3J5UGF0Y2hlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHN0b3BQcm9ncmVzc09uSGlzdG9yeVVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4ge1xuICAgICAgaWYgKGlzSGlzdG9yeVBhdGNoZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3JpZ2luYWxQdXNoU3RhdGUgPSBoaXN0b3J5LnB1c2hTdGF0ZS5iaW5kKGhpc3RvcnkpO1xuICAgICAgaGlzdG9yeS5wdXNoU3RhdGUgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCB1cmwgPSBhcmdzWzJdO1xuICAgICAgICBpZiAodXJsICYmIGlzU2FtZVBhdGhuYW1lKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB1cmwpICYmIChpZ25vcmVTZWFyY2hQYXJhbXMgfHwgaGFzU2FtZVF1ZXJ5UGFyYW1ldGVycyh3aW5kb3cubG9jYXRpb24uaHJlZiwgdXJsKSkpIHtcbiAgICAgICAgICBvcmlnaW5hbFB1c2hTdGF0ZSguLi5hcmdzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RvcFByb2dyZXNzKCk7XG4gICAgICAgIG9yaWdpbmFsUHVzaFN0YXRlKC4uLmFyZ3MpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsUmVwbGFjZVN0YXRlID0gaGlzdG9yeS5yZXBsYWNlU3RhdGUuYmluZChoaXN0b3J5KTtcbiAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgdXJsID0gYXJnc1syXTtcbiAgICAgICAgaWYgKHVybCAmJiBpc1NhbWVQYXRobmFtZSh3aW5kb3cubG9jYXRpb24uaHJlZiwgdXJsKSAmJiAoaWdub3JlU2VhcmNoUGFyYW1zIHx8IGhhc1NhbWVRdWVyeVBhcmFtZXRlcnMod2luZG93LmxvY2F0aW9uLmhyZWYsIHVybCkpKSB7XG4gICAgICAgICAgb3JpZ2luYWxSZXBsYWNlU3RhdGUoLi4uYXJncyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BQcm9ncmVzcygpO1xuICAgICAgICBvcmlnaW5hbFJlcGxhY2VTdGF0ZSguLi5hcmdzKTtcbiAgICAgIH07XG4gICAgICBpc0hpc3RvcnlQYXRjaGVkID0gdHJ1ZTtcbiAgICB9LCBcInN0b3BQcm9ncmVzc09uSGlzdG9yeVVwZGF0ZVwiKTtcbiAgICBjb25zdCBoYW5kbGVDbGljayA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGV2ZW50KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRhcmdldC5jbG9zZXN0KFwiYVwiKTtcbiAgICAgICAgY29uc3QgYW5jaG9yT3BlbnNFeHRlcm5hbGx5ID0gKGFuY2hvciA9PSBudWxsID8gdm9pZCAwIDogYW5jaG9yLnRhcmdldCkgJiYgYW5jaG9yLnRhcmdldCAhPT0gXCJfc2VsZlwiO1xuICAgICAgICBpZiAoYW5jaG9yID09PSBudWxsIHx8IGFuY2hvck9wZW5zRXh0ZXJuYWxseSB8fCBhbmNob3IuaGFzQXR0cmlidXRlKFwiZG93bmxvYWRcIikgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IC8vIFNraXAgaWYgVVJMIHBvaW50cyB0byBhIGRpZmZlcmVudCBkb21haW5cbiAgICAgICAgIWlzU2FtZUhvc3Qod2luZG93LmxvY2F0aW9uLmhyZWYsIGFuY2hvci5ocmVmKSB8fCAvLyBTa2lwIGlmIFVSTCBpcyBhIHNhbWUtcGFnZSBhbmNob3IgKGhyZWY9XCIjXCIsIGhyZWY9XCIjdG9wXCIsIGV0Yy4pLlxuICAgICAgICBpc1NhbWVQYWdlQW5jaG9yKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBhbmNob3IuaHJlZikgfHwgLy8gU2tpcCBpZiBVUkwgdXNlcyBhIG5vbi1odHRwL2h0dHBzIHByb3RvY29sIChtYWlsdG86LCB0ZWw6LCBldGMuKS5cbiAgICAgICAgIXRvQWJzb2x1dGVVUkwoYW5jaG9yLmhyZWYpLnN0YXJ0c1dpdGgoXCJodHRwXCIpIHx8IC8vIFNraXAgaWYgdGhlIFVSTCBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCBwYWdlXG4gICAgICAgIGlzU2FtZVBhdGhuYW1lKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBhbmNob3IuaHJlZikgJiYgKGlnbm9yZVNlYXJjaFBhcmFtcyB8fCBoYXNTYW1lUXVlcnlQYXJhbWV0ZXJzKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBhbmNob3IuaHJlZikpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0UHJvZ3Jlc3MoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHN0b3BQcm9ncmVzcygpO1xuICAgICAgfVxuICAgIH0sIFwiaGFuZGxlQ2xpY2tcIik7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChob2x5UHJvZ3Jlc3NSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBob2x5UHJvZ3Jlc3NSZWYuY3VycmVudCA9IG5ldyBIb2x5UHJvZ3Jlc3Moe1xuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICBpbml0aWFsUG9zaXRpb24sXG4gICAgICAgICAgZWFzaW5nLFxuICAgICAgICAgIHNwZWVkLFxuICAgICAgICAgIHpJbmRleCxcbiAgICAgICAgICBib3hTaGFkb3csXG4gICAgICAgICAgc2hvd1NwaW5uZXIsXG4gICAgICAgICAgZGlyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoU1RBUlRfSE9MWV9FVkVOVCwgc3RhcnRQcm9ncmVzcyk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFNUT1BfSE9MWV9FVkVOVCwgc3RvcFByb2dyZXNzKTtcbiAgICAgIHN0b3BQcm9ncmVzc09uSGlzdG9yeVVwZGF0ZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihTVEFSVF9IT0xZX0VWRU5ULCBzdGFydFByb2dyZXNzKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoU1RPUF9IT0xZX0VWRU5ULCBzdG9wUHJvZ3Jlc3MpO1xuICAgIH07XG4gIH0sIFtob2x5UHJvZ3Jlc3NSZWZdKTtcbiAgcmV0dXJuIG51bGw7XG59LCBcIkhvbHlMb2FkZXJcIik7XG52YXIgc3JjX2RlZmF1bHQgPSBIb2x5TG9hZGVyO1xuZXhwb3J0IHtcbiAgc3JjX2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgc3RhcnRIb2x5TG9hZGVyLFxuICBzdG9wSG9seUxvYWRlclxufTtcbiJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZ2V0T3duUHJvcFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJfX2hhc093blByb3AiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fcHJvcElzRW51bSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX19kZWZOb3JtYWxQcm9wIiwib2JqIiwia2V5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX3NwcmVhZFZhbHVlcyIsImEiLCJiIiwicHJvcCIsImNhbGwiLCJfX25hbWUiLCJ0YXJnZXQiLCJSZWFjdCIsIkRFRkFVTFRTIiwiY29sb3IiLCJpbml0aWFsUG9zaXRpb24iLCJoZWlnaHQiLCJlYXNpbmciLCJzcGVlZCIsInpJbmRleCIsInNob3dTcGlubmVyIiwiYm94U2hhZG93IiwiaWdub3JlU2VhcmNoUGFyYW1zIiwiZGlyIiwiU1RBUlRfSE9MWV9FVkVOVCIsIlNUT1BfSE9MWV9FVkVOVCIsInRvQWJzb2x1dGVVUkwiLCJ1cmwiLCJVUkwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJpc1NhbWVQYWdlQW5jaG9yIiwiY3VycmVudFVybCIsIm5ld1VybCIsImN1cnJlbnQiLCJuZXh0Iiwic3BsaXQiLCJpc1NhbWVIb3N0IiwiaG9zdG5hbWUiLCJyZXBsYWNlIiwicGFyYW1zQXJlRXF1YWwiLCJwYXJhbXMxIiwicGFyYW1zMiIsIkFycmF5IiwiZnJvbSIsImV2ZXJ5IiwiaGFzIiwiZ2V0IiwiaGFzU2FtZVF1ZXJ5UGFyYW1ldGVycyIsImN1cnJlbnRQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJuZXh0UGFyYW1zIiwiaXNTYW1lUGF0aG5hbWUiLCJwYXRobmFtZSIsImNsYW1wIiwibiIsIm1pbiIsIm1heCIsIk1hdGgiLCJxdWV1ZSIsInBlbmRpbmciLCJmbiIsInNoaWZ0IiwicHVzaCIsImxlbmd0aCIsInJlcGFpbnRFbGVtZW50Iiwib2Zmc2V0V2lkdGgiLCJfSG9seVByb2dyZXNzIiwiY29uc3RydWN0b3IiLCJjdXN0b21TZXR0aW5ncyIsInNldFRvIiwiaXNTdGFydGVkIiwicHJvZ3Jlc3NOIiwic2V0dGluZ3MiLCJwcm9ncmVzc0JhciIsImdldE9yQ3JlYXRlQmFyIiwiYmFyIiwiYXNzaWduIiwic3R5bGUiLCJiYXJQb3NpdGlvbkNTUyIsInRyYW5zaXRpb24iLCJvcGFjaXR5Iiwic2V0VGltZW91dCIsInJlbW92ZUJhckZyb21ET00iLCJyZW1vdmVTcGlubmVyRnJvbURPTSIsInRvQmFyUGVyY2VudGFnZSIsInN0YXJ0Iiwic3RhcnRUcmlja2xlIiwiY3JlYXRlU3Bpbm5lciIsInJ1biIsImluY3JlbWVudFN0YXR1cyIsImNvbXBsZXRlIiwiY2FsY3VsYXRlSW5jcmVtZW50Iiwic3RhdHVzIiwiYmFzZSIsInNjYWxlIiwiZXhwIiwiYW1vdW50IiwiY3JlYXRlQmFyIiwiZnJvbVN0YXJ0IiwiX2EiLCJfYiIsImJhckNvbnRhaW5lciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlkIiwicG9pbnRlckV2ZW50cyIsImlubmVySFRNTCIsInF1ZXJ5U2VsZWN0b3IiLCJwZXJjZW50YWdlIiwiYmFja2dyb3VuZCIsInRvU3RyaW5nIiwicG9zaXRpb24iLCJ3aWR0aCIsInRvcCIsImxlZnQiLCJ0cmFuc2Zvcm0iLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJnZXRFbGVtZW50QnlJZCIsInNwaW5uZXIiLCJkaXNwbGF5IiwicmlnaHQiLCJib3hTaXppbmciLCJib3JkZXIiLCJib3JkZXJUb3BDb2xvciIsImJvcmRlckxlZnRDb2xvciIsImJvcmRlclJhZGl1cyIsImFuaW1hdGlvbiIsImtleWZyYW1lcyIsInJlbW92ZSIsImdldFRyYW5zZm9ybVN0cmF0ZWd5IiwicHJlZml4ZXMiLCJ0cmFuc2Zvcm1Qcm9wIiwiaSIsInRyYW5zZm9ybVN0cmF0ZWd5IiwiYmFyUG9zaXRpb24iLCJtYXJnaW5MZWZ0IiwiSG9seVByb2dyZXNzIiwic3RhcnRIb2x5TG9hZGVyIiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50Iiwic3RvcEhvbHlMb2FkZXIiLCJIb2x5TG9hZGVyIiwiaG9seVByb2dyZXNzUmVmIiwidXNlUmVmIiwidXNlRWZmZWN0Iiwic3RhcnRQcm9ncmVzcyIsImVycm9yIiwic3RvcFByb2dyZXNzIiwiaXNIaXN0b3J5UGF0Y2hlZCIsInN0b3BQcm9ncmVzc09uSGlzdG9yeVVwZGF0ZSIsIm9yaWdpbmFsUHVzaFN0YXRlIiwiaGlzdG9yeSIsInB1c2hTdGF0ZSIsImJpbmQiLCJhcmdzIiwib3JpZ2luYWxSZXBsYWNlU3RhdGUiLCJyZXBsYWNlU3RhdGUiLCJoYW5kbGVDbGljayIsImV2ZW50IiwiYW5jaG9yIiwiY2xvc2VzdCIsImFuY2hvck9wZW5zRXh0ZXJuYWxseSIsImhhc0F0dHJpYnV0ZSIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic3RhcnRzV2l0aCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic3JjX2RlZmF1bHQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/holy-loader/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/holy-loader/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/holy-loader/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $$typeof: () => (/* binding */ $$typeof),
/* harmony export */   __esModule: () => (/* binding */ __esModule),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   startHolyLoader: () => (/* binding */ e0),
/* harmony export */   stopHolyLoader: () => (/* binding */ e1)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/home/mohamed/next-ecommerce-shopco/node_modules/holy-loader/dist/index.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/home/mohamed/next-ecommerce-shopco/node_modules/holy-loader/dist/index.js#default`));

const e0 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/home/mohamed/next-ecommerce-shopco/node_modules/holy-loader/dist/index.js#startHolyLoader`);

const e1 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/home/mohamed/next-ecommerce-shopco/node_modules/holy-loader/dist/index.js#stopHolyLoader`);


/***/ })

};
;